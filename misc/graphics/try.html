<!DOCTYPE HTML>
<html>
<head>
  <style>
  body {
    margin: 0px;
    padding: 0px;
  }
  </style>
</head>
<body>
  <div id="container"></div>
  <script src="three/build/three.min.js"></script>
  <script defer="content">

    var mouseX, mouseY;
    var radius = 50, segments = 100, rings = 100;
    var WIDTH = window.innerWidth, HEIGHT = window.innerHeight,
      VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 1, FAR = 1000;
    var renderer;
    var camera;
    var scene;
    var pointLight;
    var sphere;
    var button;
    var projector = new THREE.Projector();
    var objects = [];

    function makePointLight() {
      // create a point light
      var point = new THREE.PointLight(0xffffff);
      // set its position
      point.position.x = 100;
      point.position.y = 100;
      point.position.z = 500;
      return point;
    }

    function makeSphere(material, radius, segments, rings) {
      //texture only works when hosted on server
     
      var sphereMaterial = material;
      var sphere = new THREE.Mesh(
        new THREE.SphereGeometry(radius, segments, rings), 
        sphereMaterial
      );
      return sphere;
    }

    function update(){
      /*if (mouseX <= 50 && mouseX <= 200 && mouseY <= 50 && mouseY <= 200) {
        var sphereMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
        sphere.material = sphereMaterial;
     } else {
       var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x00ff00});
        sphere.material = sphereMaterial;
     }*/
      renderer.render(scene, camera);
    }

    function onMouseMove(event) {
      mouseX = event.clientX - window.innerWidth/2;
      mouseY = event.clientY - window.innerHeight/2;
    }

    document.addEventListener( 'mousedown', onMouseDown, false );



  function onMouseDown( event ) {

   event.preventDefault();
        var vector = new THREE.Vector3((event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
        projector.unprojectVector( vector, camera );

        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        var intersects = raycaster.intersectObjects( objects );
        if (intersects.length > 0) {
          var clicked = intersects[0].object;
          if (clicked.name == "b") {
            //sphere.material.color.setHex(Math.random() * 0xffffff);
            
            sphere.rotation.y += 50;
          }
        }
}

    function init() {
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(WIDTH, HEIGHT);

      var container = document.createElement('div');
      document.body.appendChild(container);

      container.appendChild(renderer.domElement);
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mousedown', onMouseDown, false);
      
      setInterval(update,1000/30);
      camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
      camera.position.z = 200;
      scene = new THREE.Scene();
      pointLight = makePointLight();

       var mapTexture = THREE.ImageUtils.loadTexture("earth.png");
      //mapTexture.wrapS = THREE.RepeatWrapping;
     // mapTexture.wrapT = THREE.RepeatWrapping;
      //mapTexture.repeat.set( 4, 4 );
     //mapTexture.magFilter = THREE.NearestFilter;
     // mapTexture.minFilter = THREE.LinearMipMapLinearFilter;
        sphere = makeSphere(new THREE.MeshLambertMaterial({
        map: mapTexture}),
                          radius, segments, rings);
      sphere.name = "globe";
      objects.push(sphere);
      button = makeSphere(new THREE.MeshBasicMaterial({color:0xdddddd}), 20, 20, 20);
      button.name = "b";
      objects.push(button);
      scene.add(button);
      scene.add(camera);
      scene.add(pointLight);
      scene.add(sphere);
      button.position.x = -80;
      button.position.y = 40;
      renderer.render(scene, camera);
    }

    init();

  </script>
</body>
</html>
