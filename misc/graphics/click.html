
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js canvas - interactive - cubes</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

    <script src="three/build/three.min.js"></script>

    <script>

      var container;
      var camera, scene, projector, renderer, pointLight;
      var particleMaterial;
      var radius = 230, segments = 100, rings = 100;
      var objects = [];

      init();
      animate();

      function makePointLight() {
        // create a point light
        var point = new THREE.PointLight(0xffffff);
        // set its position
        point.position.x = 100;
        point.position.y = 100;
        point.position.z = 100;
        return point;
      }

      function makeSphere(material, radius, segments, rings) {
      //texture only works when hosted on server
      //var mapTexture = THREE.ImageUtils.loadTexture("http://i.jootix.com/o/earth-satellite-map-earth-satellite-map.jpg");
      /*texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set( 4, 4 );*/
      var sphereMaterial = material;
      var sphere = new THREE.Mesh(
        new THREE.SphereGeometry(radius, segments, rings), 
        sphereMaterial
      );
      return sphere;
    }

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        container.appendChild( info );

        pointLight = makePointLight();
        
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.set( 0, 300, 500 );

        scene = new THREE.Scene();

        var geometry = new THREE.CubeGeometry( 100, 100, 100 );

        var object = makeSphere(new THREE.MeshLambertMaterial({color:  0x0000ff}), radius, segments, rings);

        object.position.x = 20;
        object.position.y = 250;
        object.position.z = 10;
/*
          var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.5 } ) );
          object.position.x = Math.random() * 800 - 400;
          object.position.y = Math.random() * 800 - 400;
          object.position.z = Math.random() * 800 - 400;

          object.scale.x = Math.random() * 2 + 1;
          object.scale.y = Math.random() * 2 + 1;
          object.scale.z = Math.random() * 2 + 1;

          object.rotation.x = Math.random() * 2 * Math.PI;
          object.rotation.y = Math.random() * 2 * Math.PI;
          object.rotation.z = Math.random() * 2 * Math.PI; */
          scene.add(pointLight);

          scene.add( object );

          objects.push( object );

        

        var PI2 = Math.PI * 2;
        particleMaterial = new THREE.ParticleCanvasMaterial( {

          color: 0x000000,
          program: function ( context ) {

            context.beginPath();
            context.arc( 0, 0, 1, 0, PI2, true );
            context.closePath();
            context.fill();

          }

        } );

        projector = new THREE.Projector();

        renderer = new THREE.CanvasRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.appendChild( renderer.domElement );

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
        projector.unprojectVector( vector, camera );

        var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

        var intersects = raycaster.intersectObjects( objects );
        if (intersects.length > 0) {
          intersects[0].object.material.color.setHex( Math.random() * 0xffffff );
          var particle = new THREE.Particle( particleMaterial );
          particle.position = intersects[0].point;
          particle.scale.x = particle.scale.y = 8;
          scene.add( particle );
        }
      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();

      }

      var radius = 600;
      var theta = 0;

      function render() {

        /*theta += 0.1;

        camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );
        camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );
        camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );
        camera.lookAt( scene.position );*/

        renderer.render( scene, camera );

      }

    </script>

  </body>
</html>
